# OCA5Pereopredelenie
Методы наследования
Наследование класса предоставляет нам доступ к элементам publicи protectedчленам родительского класса, но также устанавливает условия для конфликтов между методами,
определенными как в родительском классе, так и в подклассе. В этом разделе мы рассмотрим правила наследования методов и то, как Java обрабатывает такие сценарии.
Переопределение метода
Что если есть метод, определенный как в родительском, так и в дочернем классе? Например, вы можете определить новую версию существующего метода в дочернем классе,
который использует определение в родительском классе. В этом случае вы можете переопределить метод методом, объявив новый метод с сигнатурой и 
типом возврата в качестве метода в родительском классе. Как вы помните из главы 4, сигнатура метода включает в себя имя и список входных параметров.
Когда вы переопределяете метод, вы можете ссылаться на родительскую версию метода, используя superключевое слово.
Таким образом, ключевые слова thisи superпозволяют выбирать между текущей и родительской версией метода, соответственно. Мы проиллюстрируем это на следующем примере:

public class Canine { 
 public double getAverageWeight() { 
   return 50; 
 }}
public class Wolf extends Canine {
  public double getAverageWeight() { 
   return super.getAverageWeight()+20;
  } 
 public static void main(String[] args) { 
   System.out.println(new Canine().getAverageWeight());  
  System.out.println(new Wolf().getAverageWeight()); 
 }}
 
 

В этом примере, в котором дочерний класс Wolfпереопределяет родительский класс Canine, метод getAverageWeight()выполняется без проблем и выдает следующее:
50.00
70.00

Вы могли бы задаться вопросом, superтребовалось ли использование метода ребенка? Например, что будет выводить следующий код, если мы удалим superключевое 
слово в getAverageWeight()методе Wolfкласса?
public double getAverageWeight() { 
 return getAverageWeight()+20;  // INFINITE LOOP
}
В этом примере компилятор не будет вызывать родительский Canineметод; он будет вызывать текущий Wolfметод, поскольку он будет думать, что вы выполняете рекурсивный вызов. 
Рекурсивная функция - это та, которая вызывает себя как часть выполнения, и она распространена в программировании. Рекурсивная функция должна иметь условие завершения.
В этом примере нет условия завершения; поэтому приложение будет пытаться бесконечно вызывать себя и выдавать ошибку переполнения стека во время выполнения.

Однако переопределение метода не без ограничений. Компилятор выполняет следующие проверки при переопределении не частного метода:
1.	Метод в дочернем классе должен иметь ту же сигнатуру, что и метод в родительском классе.
2.	Метод в дочернем классе должен быть как минимум доступным или более доступным, чем метод в родительском классе.
3.	Метод в дочернем классе не может выдавать проверенное исключение, которое является новым или более широким, чем класс любого исключения, выданного
в методе родительского класса.
4.	Если метод возвращает значение, оно должно быть тем же или подклассом метода в родительском классе, известном как ковариантные возвращаемые типы .
Первое правило отмены метода несколько самоочевидно.Если два метода имеют одинаковые имена, но разные подписи, методы перегружаются, а не переопределяются.
Как вы, возможно, помните из нашего обсуждения перегруженных методов в главе 4, методы не связаны друг с другом и не имеют общих свойств.


Перегрузка и переопределение

Далее мы рассмотрим различия между перегрузкой и переопределением. Какие методы в BobcatKittenперегрузке или переопределить один в Bobcat?

1:    public class Bobcat {
2:       public void findDen() { }
3:    }



1:    public class BobcatKitten extends Bobcat {
2:       public void findDen() { }
3:       public void findDen(boolean b) { }
4:       public int findden() throws Exception { return 0; }
5:    }
Тот, что в строке 2, является переопределением, потому что он имеет одинаковую сигнатуру метода. Тот, что в строке 3,
является перегруженным методом, потому что он имеет то же имя метода, но другой список параметров. Тот, что в строке 4,
не является переопределением или перегрузкой, поскольку имеет другое имя метода. Помните, что Java чувствительна к регистру.
Чтобы просмотреть, перегрузка и переопределение происходят только тогда, когда имя метода совпадает. 
Далее overridingпроисходит только тогда, когда сигнатура метода одинакова. Это имя метода и список параметров. Для получения ,
параметры методы должны варьироваться в зависимости от типа и / или номера.method signatureoverloading
При наличии нескольких перегруженных методов Java сначала ищет наиболее близкое совпадение. Он пытается найти следующее:
•	Точное соответствие по типу
•	Соответствие типу суперкласса
•	Преобразование в больший примитивный тип
•	Преобразование в тип автобоксов
•	списки параметры
Для переопределения переопределенный метод имеет несколько правил:
•	Модификатор доступа должен быть таким же или более доступным.
•	Тип возвращаемого значения должен быть того же или более ограничительного типа, также известного как covariant return types.
•	Если выброшены какие-либо проверенные исключения, разрешено выбрасывать только те же самые исключения или подклассы этих исключений.
Методы не должны быть static. (Если они есть, метод скрыт и не переопределен.)

